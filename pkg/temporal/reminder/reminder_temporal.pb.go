// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: reminder/reminder.proto
package reminderv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	gohomedir "github.com/mitchellh/go-homedir"
	cliv3 "github.com/urfave/cli/v3"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	"log/slog"
	"os"
	"sort"
	"sync"
	"sync/atomic"
	"time"
)

// ReminderTaskQueue is the default task-queue for a reminder.v1.Reminder worker
var ReminderTaskQueue = "reminder-v1"

// reminder.v1.Reminder workflow names
const (
	ScheduleReminderWorkflowName = "reminder.v1.Reminder.ScheduleReminder"
)

// reminder.v1.Reminder workflow id expressions
var (
	ScheduleReminderIdexpression = expression.MustParseExpression("reminder/${! id }")
)

// reminder.v1.Reminder activity names
const (
	SendTelegramNotificationActivityName = "reminder.v1.Reminder.SendTelegramNotification"
)

// reminder.v1.Reminder query names
const (
	GetReminderStatusQueryName = "reminder.v1.Reminder.GetReminderStatus"
)

// reminder.v1.Reminder signal names
const (
	CancelReminderSignalName = "reminder.v1.Reminder.CancelReminder"
)

// ReminderClient describes a client for a(n) reminder.v1.Reminder worker
type ReminderClient interface {
	// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
	ScheduleReminder(ctx context.Context, req *ScheduleReminderRequest, opts ...*ScheduleReminderOptions) (*ScheduleReminderResponse, error)

	// ScheduleReminderAsync starts a(n) reminder.v1.Reminder.ScheduleReminder workflow and returns a handle to the workflow run
	ScheduleReminderAsync(ctx context.Context, req *ScheduleReminderRequest, opts ...*ScheduleReminderOptions) (ScheduleReminderRun, error)

	// GetScheduleReminder retrieves a handle to an existing reminder.v1.Reminder.ScheduleReminder workflow execution
	GetScheduleReminder(ctx context.Context, workflowID string, runID string) ScheduleReminderRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// GetReminderStatus запрос текущего статуса напоминания
	GetReminderStatus(ctx context.Context, workflowID string, runID string) (*GetReminderStatusResponse, error)

	// CancelReminder сигнал для отмены напоминания
	CancelReminder(ctx context.Context, workflowID string, runID string) error
}

// reminderClient implements a temporal client for a reminder.v1.Reminder service
type reminderClient struct {
	client client.Client
	log    *slog.Logger
}

// NewReminderClient initializes a new reminder.v1.Reminder client
func NewReminderClient(c client.Client, options ...*reminderClientOptions) ReminderClient {
	var cfg *reminderClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewReminderClientOptions()
	}
	return &reminderClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewReminderClientWithOptions initializes a new Reminder client with the given options
func NewReminderClientWithOptions(c client.Client, opts client.Options, options ...*reminderClientOptions) (ReminderClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *reminderClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewReminderClientOptions()
	}
	return &reminderClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// reminderClientOptions describes optional runtime configuration for a ReminderClient
type reminderClientOptions struct {
	log *slog.Logger
}

// NewReminderClientOptions initializes a new reminderClientOptions value
func NewReminderClientOptions() *reminderClientOptions {
	return &reminderClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *reminderClientOptions) WithLogger(l *slog.Logger) *reminderClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *reminderClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
func (c *reminderClient) ScheduleReminder(ctx context.Context, req *ScheduleReminderRequest, options ...*ScheduleReminderOptions) (*ScheduleReminderResponse, error) {
	run, err := c.ScheduleReminderAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
func (c *reminderClient) ScheduleReminderAsync(ctx context.Context, req *ScheduleReminderRequest, options ...*ScheduleReminderOptions) (ScheduleReminderRun, error) {
	var o *ScheduleReminderOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewScheduleReminderOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ScheduleReminderWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &scheduleReminderRun{
		client: c,
		run:    run,
	}, nil
}

// GetScheduleReminder fetches an existing reminder.v1.Reminder.ScheduleReminder execution
func (c *reminderClient) GetScheduleReminder(ctx context.Context, workflowID string, runID string) ScheduleReminderRun {
	return &scheduleReminderRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *reminderClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *reminderClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// GetReminderStatus запрос текущего статуса напоминания
func (c *reminderClient) GetReminderStatus(ctx context.Context, workflowID string, runID string) (*GetReminderStatusResponse, error) {
	var resp GetReminderStatusResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, GetReminderStatusQueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// CancelReminder сигнал для отмены напоминания
func (c *reminderClient) CancelReminder(ctx context.Context, workflowID string, runID string) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, CancelReminderSignalName, nil)
}

// ScheduleReminderOptions provides configuration for a reminder.v1.Reminder.ScheduleReminder workflow operation
type ScheduleReminderOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewScheduleReminderOptions initializes a new ScheduleReminderOptions value
func NewScheduleReminderOptions() *ScheduleReminderOptions {
	return &ScheduleReminderOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ScheduleReminderOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ScheduleReminderIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ScheduleReminderWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ReminderTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 2592000000000000 // 4 weeks 2 days
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ScheduleReminderOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ScheduleReminderOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *ScheduleReminderOptions) WithEnableEagerStart(enable bool) *ScheduleReminderOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ScheduleReminderOptions) WithExecutionTimeout(d time.Duration) *ScheduleReminderOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ScheduleReminderOptions) WithID(id string) *ScheduleReminderOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ScheduleReminderOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ScheduleReminderOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ScheduleReminderOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ScheduleReminderOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ScheduleReminderOptions) WithRunTimeout(d time.Duration) *ScheduleReminderOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ScheduleReminderOptions) WithSearchAttributes(sa map[string]any) *ScheduleReminderOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ScheduleReminderOptions) WithTaskTimeout(d time.Duration) *ScheduleReminderOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ScheduleReminderOptions) WithTaskQueue(tq string) *ScheduleReminderOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *ScheduleReminderOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *ScheduleReminderOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *ScheduleReminderOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *ScheduleReminderOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// ScheduleReminderRun describes a(n) reminder.v1.Reminder.ScheduleReminder workflow run
type ScheduleReminderRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ScheduleReminderResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// GetReminderStatus запрос текущего статуса напоминания
	GetReminderStatus(ctx context.Context) (*GetReminderStatusResponse, error)

	// CancelReminder сигнал для отмены напоминания
	CancelReminder(ctx context.Context) error
}

// scheduleReminderRun provides an internal implementation of a(n) ScheduleReminderRunRun
type scheduleReminderRun struct {
	client *reminderClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *scheduleReminderRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *scheduleReminderRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *scheduleReminderRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *scheduleReminderRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *scheduleReminderRun) Get(ctx context.Context) (*ScheduleReminderResponse, error) {
	var resp ScheduleReminderResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *scheduleReminderRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// GetReminderStatus запрос текущего статуса напоминания
func (r *scheduleReminderRun) GetReminderStatus(ctx context.Context) (*GetReminderStatusResponse, error) {
	return r.client.GetReminderStatus(ctx, r.ID(), "")
}

// CancelReminder сигнал для отмены напоминания
func (r *scheduleReminderRun) CancelReminder(ctx context.Context) error {
	return r.client.CancelReminder(ctx, r.ID(), "")
}

// Reference to generated workflow functions
var (
	// reminderRegistrationMutex is a mutex for registering reminder.v1.Reminder workflows
	reminderRegistrationMutex sync.Mutex
	// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
	ScheduleReminderFunction func(workflow.Context, *ScheduleReminderRequest) (*ScheduleReminderResponse, error)
)

// ReminderWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// ReminderWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	ReminderWorkflowFunctions interface {
		// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
		ScheduleReminder(workflow.Context, *ScheduleReminderRequest) (*ScheduleReminderResponse, error)
	}
	// reminderWorkflowFunctions provides an internal ReminderWorkflowFunctions implementation
	reminderWorkflowFunctions struct{}
)

func NewReminderWorkflowFunctions() ReminderWorkflowFunctions {
	return &reminderWorkflowFunctions{}
}

// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
func (f *reminderWorkflowFunctions) ScheduleReminder(ctx workflow.Context, req *ScheduleReminderRequest) (*ScheduleReminderResponse, error) {
	if ScheduleReminderFunction == nil {
		return nil, errors.New("ScheduleReminder requires workflow registration via RegisterReminderWorkflows or RegisterScheduleReminderWorkflow")
	}
	return ScheduleReminderFunction(ctx, req)
}

// ReminderWorkflows provides methods for initializing new reminder.v1.Reminder workflow values
type ReminderWorkflows interface {
	// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
	ScheduleReminder(ctx workflow.Context, input *ScheduleReminderWorkflowInput) (ScheduleReminderWorkflow, error)
}

// RegisterReminderWorkflows registers reminder.v1.Reminder workflows with the given worker
func RegisterReminderWorkflows(r worker.WorkflowRegistry, workflows ReminderWorkflows) {
	RegisterScheduleReminderWorkflow(r, workflows.ScheduleReminder)
}

// RegisterScheduleReminderWorkflow registers a reminder.v1.Reminder.ScheduleReminder workflow with the given worker
func RegisterScheduleReminderWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ScheduleReminderWorkflowInput) (ScheduleReminderWorkflow, error)) {
	reminderRegistrationMutex.Lock()
	defer reminderRegistrationMutex.Unlock()
	ScheduleReminderFunction = buildScheduleReminder(wf)
	r.RegisterWorkflowWithOptions(ScheduleReminderFunction, workflow.RegisterOptions{Name: ScheduleReminderWorkflowName})
}

// buildScheduleReminder converts a ScheduleReminder workflow struct into a valid workflow function
func buildScheduleReminder(ctor func(workflow.Context, *ScheduleReminderWorkflowInput) (ScheduleReminderWorkflow, error)) func(workflow.Context, *ScheduleReminderRequest) (*ScheduleReminderResponse, error) {
	return func(ctx workflow.Context, req *ScheduleReminderRequest) (*ScheduleReminderResponse, error) {
		input := &ScheduleReminderWorkflowInput{
			Req: req,
			CancelReminder: &CancelReminderSignal{
				Channel: workflow.GetSignalChannel(ctx, CancelReminderSignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		if err := workflow.SetQueryHandler(ctx, GetReminderStatusQueryName, wf.GetReminderStatus); err != nil {
			return nil, err
		}
		return wf.Execute(ctx)
	}
}

// ScheduleReminderWorkflowInput describes the input to a(n) reminder.v1.Reminder.ScheduleReminder workflow constructor
type ScheduleReminderWorkflowInput struct {
	Req            *ScheduleReminderRequest
	CancelReminder *CancelReminderSignal
}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *ScheduleReminderWorkflowInput) ContinueAsNew(ctx workflow.Context, input *ScheduleReminderRequest, options ...workflow.ContinueAsNewErrorOptions) (*ScheduleReminderResponse, error) {
	next := i.Req
	if input != nil {
		next = input
	}
	if len(options) > 0 {
		return nil, workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], ScheduleReminderWorkflowName, next)
	}
	return nil, workflow.NewContinueAsNewError(ctx, ScheduleReminderWorkflowName, next)
}

// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
//
// workflow details: (name: "reminder.v1.Reminder.ScheduleReminder", id: "reminder/${! id }")
type ScheduleReminderWorkflow interface {
	// Execute defines the entrypoint to a(n) reminder.v1.Reminder.ScheduleReminder workflow
	Execute(ctx workflow.Context) (*ScheduleReminderResponse, error)

	// GetReminderStatus запрос текущего статуса напоминания
	GetReminderStatus() (*GetReminderStatusResponse, error)
}

// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
func ScheduleReminderChild(ctx workflow.Context, req *ScheduleReminderRequest, options ...*ScheduleReminderChildOptions) (*ScheduleReminderResponse, error) {
	childRun, err := ScheduleReminderChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление
func ScheduleReminderChildAsync(ctx workflow.Context, req *ScheduleReminderRequest, options ...*ScheduleReminderChildOptions) (*ScheduleReminderChildRun, error) {
	var o *ScheduleReminderChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewScheduleReminderChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &ScheduleReminderChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ScheduleReminderWorkflowName, req)}, nil
}

// ScheduleReminderChildOptions provides configuration for a child reminder.v1.Reminder.ScheduleReminder workflow operation
type ScheduleReminderChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewScheduleReminderChildOptions initializes a new ScheduleReminderChildOptions value
func NewScheduleReminderChildOptions() *ScheduleReminderChildOptions {
	return &ScheduleReminderChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ScheduleReminderChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ScheduleReminderIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ScheduleReminderWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ScheduleReminderWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ScheduleReminderIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ScheduleReminderWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ReminderTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 2592000000000000 // 4 weeks 2 days
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ScheduleReminderChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ScheduleReminderChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *ScheduleReminderChildOptions) WithDataConverter(dc converter.DataConverter) *ScheduleReminderChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ScheduleReminderChildOptions) WithExecutionTimeout(d time.Duration) *ScheduleReminderChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ScheduleReminderChildOptions) WithID(id string) *ScheduleReminderChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ScheduleReminderChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ScheduleReminderChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ScheduleReminderChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ScheduleReminderChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ScheduleReminderChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ScheduleReminderChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ScheduleReminderChildOptions) WithRunTimeout(d time.Duration) *ScheduleReminderChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ScheduleReminderChildOptions) WithSearchAttributes(sa map[string]any) *ScheduleReminderChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ScheduleReminderChildOptions) WithTaskTimeout(d time.Duration) *ScheduleReminderChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ScheduleReminderChildOptions) WithTaskQueue(tq string) *ScheduleReminderChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *ScheduleReminderChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *ScheduleReminderChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ScheduleReminderChildOptions) WithWaitForCancellation(wait bool) *ScheduleReminderChildOptions {
	o.waitForCancellation = &wait
	return o
}

// ScheduleReminderChildRun describes a child ScheduleReminder workflow run
type ScheduleReminderChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ScheduleReminderChildRun) Get(ctx workflow.Context) (*ScheduleReminderResponse, error) {
	var resp ScheduleReminderResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ScheduleReminderChildRun) Select(sel workflow.Selector, fn func(*ScheduleReminderChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ScheduleReminderChildRun) SelectStart(sel workflow.Selector, fn func(*ScheduleReminderChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ScheduleReminderChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// CancelReminder sends a(n) "reminder.v1.Reminder.CancelReminder" signal request to the child workflow
func (r *ScheduleReminderChildRun) CancelReminder(ctx workflow.Context) error {
	return r.CancelReminderAsync(ctx).Get(ctx, nil)
}

// CancelReminderAsync sends a(n) "reminder.v1.Reminder.CancelReminder" signal request to the child workflow
func (r *ScheduleReminderChildRun) CancelReminderAsync(ctx workflow.Context) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, CancelReminderSignalName, nil)
}

// CancelReminderSignal describes a(n) reminder.v1.Reminder.CancelReminder signal
type CancelReminderSignal struct {
	Channel workflow.ReceiveChannel
}

// NewCancelReminderSignal initializes a new reminder.v1.Reminder.CancelReminder signal wrapper
func NewCancelReminderSignal(ctx workflow.Context) *CancelReminderSignal {
	return &CancelReminderSignal{Channel: workflow.GetSignalChannel(ctx, CancelReminderSignalName)}
}

// Receive blocks until a(n) reminder.v1.Reminder.CancelReminder signal is received
func (s *CancelReminderSignal) Receive(ctx workflow.Context) bool {
	more := s.Channel.Receive(ctx, nil)
	return more
}

// ReceiveAsync checks for a reminder.v1.Reminder.CancelReminder signal without blocking
func (s *CancelReminderSignal) ReceiveAsync() bool {
	return s.Channel.ReceiveAsync(nil)
}

// ReceiveWithTimeout blocks until a(n) reminder.v1.Reminder.CancelReminder signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
func (s *CancelReminderSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (ok bool, more bool) {
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, nil); !ok {
		return false, more
	}
	return
}

// Select checks for a(n) reminder.v1.Reminder.CancelReminder signal without blocking
func (s *CancelReminderSignal) Select(sel workflow.Selector, fn func()) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		s.ReceiveAsync()
		if fn != nil {
			fn()
		}
	})
}

// CancelReminder сигнал для отмены напоминания
func CancelReminderExternal(ctx workflow.Context, workflowID string, runID string) error {
	return CancelReminderExternalAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelReminder сигнал для отмены напоминания
func CancelReminderExternalAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, CancelReminderSignalName, nil)
}

// ReminderActivities describes available worker activities
type ReminderActivities interface {
	// SendTelegramNotification activity — отправляет сообщение в Telegram
	SendTelegramNotification(ctx context.Context, req *SendTelegramNotificationRequest) error
}

// RegisterReminderActivities registers activities with a worker
func RegisterReminderActivities(r worker.ActivityRegistry, activities ReminderActivities) {
	RegisterSendTelegramNotificationActivity(r, activities.SendTelegramNotification)
}

// RegisterSendTelegramNotificationActivity registers a reminder.v1.Reminder.SendTelegramNotification activity
func RegisterSendTelegramNotificationActivity(r worker.ActivityRegistry, fn func(context.Context, *SendTelegramNotificationRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SendTelegramNotificationActivityName,
	})
}

// SendTelegramNotificationFuture describes a(n) reminder.v1.Reminder.SendTelegramNotification activity execution
type SendTelegramNotificationFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SendTelegramNotificationFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SendTelegramNotificationFuture) Select(sel workflow.Selector, fn func(*SendTelegramNotificationFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SendTelegramNotification activity — отправляет сообщение в Telegram
func SendTelegramNotification(ctx workflow.Context, req *SendTelegramNotificationRequest, options ...*SendTelegramNotificationActivityOptions) error {
	return SendTelegramNotificationAsync(ctx, req, options...).Get(ctx)
}

// SendTelegramNotification activity — отправляет сообщение в Telegram
func SendTelegramNotificationAsync(ctx workflow.Context, req *SendTelegramNotificationRequest, options ...*SendTelegramNotificationActivityOptions) *SendTelegramNotificationFuture {
	var o *SendTelegramNotificationActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSendTelegramNotificationActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SendTelegramNotificationFuture{Future: errF}
	}
	activity := SendTelegramNotificationActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &SendTelegramNotificationFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SendTelegramNotification activity — отправляет сообщение в Telegram
func SendTelegramNotificationLocal(ctx workflow.Context, req *SendTelegramNotificationRequest, options ...*SendTelegramNotificationLocalActivityOptions) error {
	return SendTelegramNotificationLocalAsync(ctx, req, options...).Get(ctx)
}

// SendTelegramNotification activity — отправляет сообщение в Telegram
func SendTelegramNotificationLocalAsync(ctx workflow.Context, req *SendTelegramNotificationRequest, options ...*SendTelegramNotificationLocalActivityOptions) *SendTelegramNotificationFuture {
	var o *SendTelegramNotificationLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSendTelegramNotificationLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SendTelegramNotificationFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SendTelegramNotificationActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &SendTelegramNotificationFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SendTelegramNotificationActivityOptions provides configuration for a(n) reminder.v1.Reminder.SendTelegramNotification activity
type SendTelegramNotificationActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSendTelegramNotificationActivityOptions initializes a new SendTelegramNotificationActivityOptions value
func NewSendTelegramNotificationActivityOptions() *SendTelegramNotificationActivityOptions {
	return &SendTelegramNotificationActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SendTelegramNotificationActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ReminderTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SendTelegramNotificationActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SendTelegramNotificationActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *SendTelegramNotificationActivityOptions) WithDataConverter(dc converter.DataConverter) *SendTelegramNotificationActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SendTelegramNotificationActivityOptions) WithHeartbeatTimeout(d time.Duration) *SendTelegramNotificationActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SendTelegramNotificationActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SendTelegramNotificationActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SendTelegramNotificationActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SendTelegramNotificationActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SendTelegramNotificationActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SendTelegramNotificationActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SendTelegramNotificationActivityOptions) WithStartToCloseTimeout(d time.Duration) *SendTelegramNotificationActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SendTelegramNotificationActivityOptions) WithTaskQueue(tq string) *SendTelegramNotificationActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SendTelegramNotificationActivityOptions) WithWaitForCancellation(wait bool) *SendTelegramNotificationActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SendTelegramNotificationLocalActivityOptions provides configuration for a(n) reminder.v1.Reminder.SendTelegramNotification activity
type SendTelegramNotificationLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *SendTelegramNotificationRequest) error
}

// NewSendTelegramNotificationLocalActivityOptions initializes a new SendTelegramNotificationLocalActivityOptions value
func NewSendTelegramNotificationLocalActivityOptions() *SendTelegramNotificationLocalActivityOptions {
	return &SendTelegramNotificationLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SendTelegramNotificationLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom reminder.v1.Reminder.SendTelegramNotification implementation
func (o *SendTelegramNotificationLocalActivityOptions) Local(fn func(context.Context, *SendTelegramNotificationRequest) error) *SendTelegramNotificationLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SendTelegramNotificationLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SendTelegramNotificationLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *SendTelegramNotificationLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *SendTelegramNotificationLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SendTelegramNotificationLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SendTelegramNotificationLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SendTelegramNotificationLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SendTelegramNotificationLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SendTelegramNotificationLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SendTelegramNotificationLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestReminderClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ReminderWorkflows
}

var _ ReminderClient = &TestReminderClient{}

// NewTestReminderClient initializes a new TestReminderClient value
func NewTestReminderClient(env *testsuite.TestWorkflowEnvironment, workflows ReminderWorkflows, activities ReminderActivities) *TestReminderClient {
	if workflows != nil {
		RegisterReminderWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterReminderActivities(env, activities)
	}
	return &TestReminderClient{env, workflows}
}

// ScheduleReminder executes a(n) reminder.v1.Reminder.ScheduleReminder workflow in the test environment
func (c *TestReminderClient) ScheduleReminder(ctx context.Context, req *ScheduleReminderRequest, opts ...*ScheduleReminderOptions) (*ScheduleReminderResponse, error) {
	run, err := c.ScheduleReminderAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ScheduleReminderAsync executes a(n) reminder.v1.Reminder.ScheduleReminder workflow in the test environment
func (c *TestReminderClient) ScheduleReminderAsync(ctx context.Context, req *ScheduleReminderRequest, options ...*ScheduleReminderOptions) (ScheduleReminderRun, error) {
	var o *ScheduleReminderOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewScheduleReminderOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testScheduleReminderRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetScheduleReminder is a noop
func (c *TestReminderClient) GetScheduleReminder(ctx context.Context, workflowID string, runID string) ScheduleReminderRun {
	return &testScheduleReminderRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestReminderClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestReminderClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// GetReminderStatus executes a reminder.v1.Reminder.GetReminderStatus query
func (c *TestReminderClient) GetReminderStatus(ctx context.Context, workflowID string, runID string) (*GetReminderStatusResponse, error) {
	val, err := c.env.QueryWorkflow(GetReminderStatusQueryName)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result GetReminderStatusResponse
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// CancelReminder executes a reminder.v1.Reminder.CancelReminder signal
func (c *TestReminderClient) CancelReminder(ctx context.Context, workflowID string, runID string) error {
	c.env.SignalWorkflow(CancelReminderSignalName, nil)
	return nil
}

var _ ScheduleReminderRun = &testScheduleReminderRun{}

// testScheduleReminderRun provides convenience methods for interacting with a(n) reminder.v1.Reminder.ScheduleReminder workflow in the test environment
type testScheduleReminderRun struct {
	client    *TestReminderClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *ScheduleReminderRequest
	workflows ReminderWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testScheduleReminderRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test reminder.v1.Reminder.ScheduleReminder workflow result
func (r *testScheduleReminderRun) Get(context.Context) (*ScheduleReminderResponse, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(ScheduleReminderWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ScheduleReminderResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test reminder.v1.Reminder.ScheduleReminder workflow run's workflow ID
func (r *testScheduleReminderRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testScheduleReminderRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testScheduleReminderRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testScheduleReminderRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// GetReminderStatus executes a reminder.v1.Reminder.GetReminderStatus query against a test reminder.v1.Reminder.ScheduleReminder workflow
func (r *testScheduleReminderRun) GetReminderStatus(ctx context.Context) (*GetReminderStatusResponse, error) {
	return r.client.GetReminderStatus(ctx, r.ID(), r.RunID())
}

// CancelReminder executes a reminder.v1.Reminder.CancelReminder signal against a test reminder.v1.Reminder.ScheduleReminder workflow
func (r *testScheduleReminderRun) CancelReminder(ctx context.Context) error {
	return r.client.CancelReminder(ctx, r.ID(), r.RunID())
}

// ReminderCliOptions describes runtime configuration for reminder.v1.Reminder cli v3
type ReminderCliOptions struct {
	after            func(context.Context, *cliv3.Command) error
	before           func(context.Context, *cliv3.Command) (context.Context, error)
	clientForCommand func(context.Context, *cliv3.Command) (client.Client, error)
	worker           func(context.Context, *cliv3.Command, client.Client) (worker.Worker, error)
}

// NewReminderCliOptions initializes a new ReminderCliOptions value
func NewReminderCliOptions() *ReminderCliOptions {
	return &ReminderCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ReminderCliOptions) WithAfter(fn func(context.Context, *cliv3.Command) error) *ReminderCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ReminderCliOptions) WithBefore(fn func(context.Context, *cliv3.Command) (context.Context, error)) *ReminderCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ReminderCliOptions) WithClient(fn func(context.Context, *cliv3.Command) (client.Client, error)) *ReminderCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ReminderCliOptions) WithWorker(fn func(context.Context, *cliv3.Command, client.Client) (worker.Worker, error)) *ReminderCliOptions {
	opts.worker = fn
	return opts
}

// NewReminderCli initializes a cli app for a(n) reminder.v1.Reminder service
func NewReminderCli(options ...*ReminderCliOptions) (*cliv3.Command, error) {
	commands, err := newReminderCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &cliv3.Command{
		Name:                      "reminder",
		Usage:                     "reminder.v1.Reminder operations",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// newReminderCommands initializes (sub)commands for a reminder.v1.Reminder cli or command
func newReminderCommands(options ...*ReminderCliOptions) ([]*cliv3.Command, error) {
	opts := &ReminderCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(ctx context.Context, cmd *cliv3.Command) (client.Client, error) {
			return client.DialContext(ctx, client.Options{})
		}
	}
	commands := []*cliv3.Command{
		{
			Name:                   "get-reminder-status",
			Usage:                  "GetReminderStatus запрос текущего статуса напоминания",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []cliv3.Flag{
				&cliv3.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&cliv3.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(ctx context.Context, cmd *cliv3.Command) error {
				c, err := opts.clientForCommand(ctx, cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewReminderClient(c)
				if resp, err := client.GetReminderStatus(ctx, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", GetReminderStatusQueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "cancel-reminder",
			Usage:                  "CancelReminder сигнал для отмены напоминания",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []cliv3.Flag{
				&cliv3.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&cliv3.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(ctx context.Context, cmd *cliv3.Command) error {
				c, err := opts.clientForCommand(ctx, cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewReminderClient(c)
				if err := client.CancelReminder(ctx, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error sending %q signal: %w", CancelReminderSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "schedule-reminder",
			Usage:                  "ScheduleReminder запускает workflow, который ждёт до remind_at и отправляет уведомление",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []cliv3.Flag{
				&cliv3.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&cliv3.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					Sources: cliv3.NewValueSourceChain(cliv3.EnvVar("TEMPORAL_TASK_QUEUE_NAME"), cliv3.EnvVar("TEMPORAL_TASK_QUEUE"), cliv3.EnvVar("TASK_QUEUE_NAME"), cliv3.EnvVar("TASK_QUEUE")),
					Value:   "reminder-v1",
				},
				&cliv3.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "id",
					Usage:    "Уникальный ID напоминания",
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "user-id",
					Usage:    "ID пользователя",
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "title",
					Usage:    "Заголовок напоминания",
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "description",
					Usage:    "Описание напоминания",
					Category: "INPUT",
				},
				&cliv3.TimestampFlag{
					Name:     "remind-at",
					Usage:    "Время, когда нужно напомнить (e.g. \"2017-01-15T01:30:15.01Z\")",
					Category: "INPUT",
					Config:   cliv3.TimestampConfig{Layouts: []string{time.RFC3339Nano}},
				},
				&cliv3.Int64Flag{
					Name:     "telegram-chat-id",
					Usage:    "Chat ID в Telegram для отправки уведомления",
					Category: "INPUT",
				},
			},
			Action: func(ctx context.Context, cmd *cliv3.Command) error {
				tc, err := opts.clientForCommand(ctx, cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewReminderClient(tc)
				req, err := UnmarshalCliFlagsToScheduleReminderRequest(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ScheduleReminderAsync(ctx, req, NewScheduleReminderOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ScheduleReminderWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(ctx); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*cliv3.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a reminder.v1.Reminder worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(ctx context.Context, cmd *cliv3.Command) error {
					c, err := opts.clientForCommand(ctx, cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(ctx, cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-ctx.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToScheduleReminderRequest unmarshals a ScheduleReminderRequest from command line flags
func UnmarshalCliFlagsToScheduleReminderRequest(cmd *cliv3.Command, options ...helpers.UnmarshalCliFlagsOptions) (*ScheduleReminderRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result ScheduleReminderRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("id"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Id = value
	}
	if flag := opts.FlagName("user-id"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.UserId = value
	}
	if flag := opts.FlagName("title"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Title = value
	}
	if flag := opts.FlagName("description"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Description = value
	}
	if flag := opts.FlagName("remind-at"); cmd.IsSet(flag) {
		v := cmd.Timestamp(flag)
		value := timestamppb.New(v)
		result.RemindAt = value
	}
	if flag := opts.FlagName("telegram-chat-id"); cmd.IsSet(flag) {
		value := cmd.Int64(flag)
		result.TelegramChatId = value
	}
	return &result, nil
}
