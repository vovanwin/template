// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package config

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/knadh/koanf/parsers/toml/v2"
	"github.com/knadh/koanf/providers/file"
	"github.com/knadh/koanf/v2"
)

// Environment представляет окружение развертывания
type Environment string

const (
	EnvLocal      Environment = "local"
	EnvDev        Environment = "dev"
	EnvStaging    Environment = "stg"
	EnvProduction Environment = "prod"
)

var (
	globalConfig *Config
	configMu     sync.RWMutex
	currentEnv   Environment
)

// LoadOptions настраивает загрузку конфигурации
type LoadOptions struct {
	// ConfigDir директория с файлами конфигурации
	ConfigDir string

	// Environment окружение для загрузки (local, dev, stg, prod)
	// Если пусто, читается из переменной окружения APP_ENV
	Environment Environment

	// EnableLocalOverride позволяет config_local.toml переопределять значения
	EnableLocalOverride bool
}

// Load загружает конфигурацию с заданными опциями
// Порядок: value.toml -> config_{env}.toml -> config_local.toml
func Load(opts *LoadOptions) (*Config, error) {
	if opts == nil {
		opts = &LoadOptions{
			ConfigDir:           "./configs",
			EnableLocalOverride: true,
		}
	}

	env := opts.Environment
	if env == "" {
		envStr := os.Getenv("APP_ENV")
		if envStr == "" {
			envStr = "dev"
		}
		env = Environment(envStr)
	}

	k := koanf.New(".")

	// 1. value.toml (константы, опционально)
	valuePath := filepath.Join(opts.ConfigDir, "value.toml")
	if _, err := os.Stat(valuePath); err == nil {
		if err := k.Load(file.Provider(valuePath), toml.Parser()); err != nil {
			return nil, fmt.Errorf("загрузка value.toml: %w", err)
		}
	}

	// 2. config_{env}.toml (обязательно)
	envPath := filepath.Join(opts.ConfigDir, fmt.Sprintf("config_%s.toml", env))
	if err := k.Load(file.Provider(envPath), toml.Parser()); err != nil {
		return nil, fmt.Errorf("загрузка config_%s.toml: %w", env, err)
	}

	// 3. config_local.toml (локальные переопределения, опционально)
	if opts.EnableLocalOverride {
		localPath := filepath.Join(opts.ConfigDir, "config_local.toml")
		if _, err := os.Stat(localPath); err == nil {
			if err := k.Load(file.Provider(localPath), toml.Parser()); err != nil {
				return nil, fmt.Errorf("загрузка config_local.toml: %w", err)
			}
		}
	}

	cfg := &Config{}
	if err := k.UnmarshalWithConf("", cfg, koanf.UnmarshalConf{Tag: "toml"}); err != nil {
		return nil, fmt.Errorf("декодирование конфига: %w", err)
	}

	configMu.Lock()
	globalConfig = cfg
	currentEnv = env
	configMu.Unlock()

	return cfg, nil
}

// MustLoad загружает конфигурацию или паникует при ошибке
func MustLoad(opts *LoadOptions) *Config {
	cfg, err := Load(opts)
	if err != nil {
		panic(fmt.Sprintf("ошибка загрузки конфига: %v", err))
	}
	return cfg
}

// Get возвращает текущий конфиг (потокобезопасно)
func Get() *Config {
	configMu.RLock()
	defer configMu.RUnlock()
	return globalConfig
}

// GetEnv возвращает текущее окружение
func GetEnv() Environment {
	configMu.RLock()
	defer configMu.RUnlock()
	return currentEnv
}

// IsProduction возвращает true если работаем в production
func IsProduction() bool {
	return GetEnv() == EnvProduction
}

// IsStg возвращает true если работаем в staging
func IsStg() bool {
	return GetEnv() == EnvStaging
}

// IsLocal возвращает true если работаем локально
func IsLocal() bool {
	return GetEnv() == EnvLocal
}
