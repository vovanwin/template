// Code generated by configgen. DO NOT EDIT.
// Код сгенерирован configgen. НЕ РЕДАКТИРОВАТЬ.

package config

import (
	"context"
	"fmt"
	"os"
	"sync"

	"github.com/BurntSushi/toml"
)

// MemoryStore — in-memory реализация FlagStore для тестов и разработки
type MemoryStore struct {
	mu     sync.RWMutex
	values map[string]any
}

// NewMemoryStore создает MemoryStore с начальными значениями
func NewMemoryStore(initial map[string]any) *MemoryStore {
	vals := make(map[string]any, len(initial))
	for k, v := range initial {
		vals[k] = v
	}
	return &MemoryStore{values: vals}
}

func (s *MemoryStore) GetBool(key string, def bool) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if v, ok := s.values[key]; ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return def
}

func (s *MemoryStore) GetInt(key string, def int) int {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if v, ok := s.values[key]; ok {
		switch n := v.(type) {
		case int:
			return n
		case int64:
			return int(n)
		}
	}
	return def
}

func (s *MemoryStore) GetFloat(key string, def float64) float64 {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if v, ok := s.values[key]; ok {
		if f, ok := v.(float64); ok {
			return f
		}
	}
	return def
}

func (s *MemoryStore) GetString(key string, def string) string {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if v, ok := s.values[key]; ok {
		if str, ok := v.(string); ok {
			return str
		}
	}
	return def
}

func (s *MemoryStore) Watch(_ context.Context, _ func(key string)) error {
	return nil
}

func (s *MemoryStore) Close() error {
	return nil
}

// Set устанавливает значение флага (для тестов)
func (s *MemoryStore) Set(key string, value any) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.values[key] = value
}

// FileStore — реализация FlagStore, читающая override значения из TOML файла
type FileStore struct {
	mu       sync.RWMutex
	values   map[string]any
	defaults map[string]any
}

// NewFileStore создает FileStore, читая overrides из указанного файла
// defaults используются для флагов, не указанных в файле
func NewFileStore(path string, defaults map[string]any) (*FileStore, error) {
	store := &FileStore{
		values:   make(map[string]any),
		defaults: defaults,
	}

	if _, err := os.Stat(path); err == nil {
		b, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("чтение %s: %w", path, err)
		}

		var raw map[string]any
		if _, err := toml.Decode(string(b), &raw); err != nil {
			return nil, fmt.Errorf("декодирование %s: %w", path, err)
		}
		store.values = raw
	}

	return store, nil
}

func (s *FileStore) get(key string) (any, bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	if v, ok := s.values[key]; ok {
		return v, true
	}
	if v, ok := s.defaults[key]; ok {
		return v, true
	}
	return nil, false
}

func (s *FileStore) GetBool(key string, def bool) bool {
	if v, ok := s.get(key); ok {
		if b, ok := v.(bool); ok {
			return b
		}
	}
	return def
}

func (s *FileStore) GetInt(key string, def int) int {
	if v, ok := s.get(key); ok {
		switch n := v.(type) {
		case int:
			return n
		case int64:
			return int(n)
		}
	}
	return def
}

func (s *FileStore) GetFloat(key string, def float64) float64 {
	if v, ok := s.get(key); ok {
		if f, ok := v.(float64); ok {
			return f
		}
	}
	return def
}

func (s *FileStore) GetString(key string, def string) string {
	if v, ok := s.get(key); ok {
		if str, ok := v.(string); ok {
			return str
		}
	}
	return def
}

func (s *FileStore) Watch(_ context.Context, _ func(key string)) error {
	return nil
}

func (s *FileStore) Close() error {
	return nil
}
